---
title: 逆序数
date: 2020-10-12
tags:
 - 算法
 - C
categories:
 -  算法
 -  笔记
---


### 题目描述
给定一个整数数组A[a0,a1,...,an],若i < j 且 ai > aj，则<ai,aj>就为一个逆序对。例如数组{3，1，4，5，2}的逆序对有<3,1>、<3,2>、<4,2>、<5,2>。编写一个实验程序采用分治法求A中逆序对的个数，即逆序数。

::: tip
采用二路归并排序这一分治法实现
:::

### 算法设计


#### 代码
```c
#include<stdio.h> 
#define N 100010

int ans;
void Merge(int a[], int s, int m, int e,int temp[])
{
	//将数组a的局部a[s,m]和a[m+1，e]合并到temp，保证temp有序
	int pb = 0;
	int p1 = s;
	int p2 = m + 1;
	while (p1 <= m && p2 <= e)
	{
		if (a[p1] < a[p2])
		{
			temp[pb++] = a[p1++];
		}
		else
		{
			ans += m - p1 + 1;
			temp[pb++] = a[p2++];
 
		}
	}
	while (p1 <= m)
	{
		temp[pb++] = a[p1++];
	}
	while (p2 <= e)
	{
		temp[pb++] = a[p2++];
	}
	for (int i = 0; i < e - s + 1; i++)
	{
		a[s + i] = temp[i];
	}
}
 
void MergeSort(int a[], int s, int e, int temp[])
{
	// s为a开始下标，e为结束的下标
	if (s < e)
	{
		int m = s + (e - s) / 2;
		MergeSort(a, s, m, temp);
		MergeSort(a, m + 1, e, temp);
		Merge(a, s, m, e, temp);
	}
	
}
 
int main()
{
	int size;
	int a[N];
	int b[N];
	
	freopen("D:\\input.txt", "r", stdin);           
	freopen("D:\\output.txt","w",stdout); 
	
	scanf("%d", &size);
	for (int i = 0; i < size; i++)
	{
		scanf("%d", &a[i]);
	}
	
	MergeSort(a, 0, size - 1, b);

	printf("逆序数共有%d个",ans);
	return 0;
}
```

#### 复杂性分析
时间复杂度：同归并排序O(nlogn)。
空间复杂度：同归并排序O(n)，因为归并排序需要用到一个临时数组。
