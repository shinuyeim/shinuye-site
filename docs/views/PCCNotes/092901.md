---
title: 二分法查找以及改进
date: 2020-09-29
tags:
 - 算法
 - C
 - 排序
categories:
 -  算法
 -  笔记
---


## 题目描述
二分搜索算法是运用分治策略的典型例子。给定已排好序的n个元素a[0:n-1]，现要在这n个元素中找出一特定的元素x。首先较容易想到的是用顺序搜索方法，逐个比较a[0:n-1]中的元素，直至找出元素x或搜索遍整个数组后 确定x不在其中。这个方法没有很好的利用n个元素已排好序这个条件，因此，在最坏的情况下，顺序搜索方法需要O(n)次比较。


### 算法设计

二分搜索方法充分利用了元素间的次序关系，采用分治策略，可在最坏的情况下用O(logn)时间完成所搜任务。二分搜索算法的进本思想是，将n个元素分成个数大致相同的两半，取a[n/2]与x作比较。如果x = a[n/2]，则找到x，算法终止; 如果x < a[n/2]，则只在数组a的左半部继续搜索x; 如果x > a[n/2]，则只在数组a的右半部继续搜索x。具体算法可描述如下：

```c
int BinarySearch(int a[], int x, int n){ //在a[0]<=a[1]<=...<=a[n-1]中搜索.
    //找不到x时返回其在数组中的位置，否则返回-1
    int left = 0;  int right = n - 1;

    while(left > right){
        int middle == (left + right) / 2;
        if(x == a[middle]) return middle;
        if(x > a[middle])
            left = middle + 1;
        if(x < a[middle])
            right = middle - 1;
    }
    return -1;
}
```

#### 时间复杂性分析
在执行一次算法的while循环，带搜索数组的大小减小一半。因此，在最坏情况下，while循环被执行了O(logn)次。循环体内运算时间需要O(1)，因此整个算法在最坏情况下的计算时间复杂性为O(logn)。
